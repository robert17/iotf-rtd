# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2015, IBM Corporation
# This file is distributed under the same license as the IBM IOT Foundation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: IBM IOT Foundation 1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-07-23 10:01+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ..\docs\messaging\mqtt.rst:3
msgid "MQTT"
msgstr ""
"MQTT"

#: ..\docs\messaging\mqtt.rst:5
msgid "The primary mechanism that devices and applications use to communicate with the IBM Internet of Things Foundation is MQTT; this is a protocol designed for the efficient exchange of real-time data with sensor and mobile devices."
msgstr ""
"디바이스와 애플리케이션이 IBM Internet of Things Foundation과 통신하는 데 사용하는 기본 메커니즘은 MQTT입니다. MQTT는 실시간 데이터와 센서 및 모바일 디바이스의 효율적인 교환을 위해 설계된 프로토콜입니다. "

#: ..\docs\messaging\mqtt.rst:10
msgid "MQTT runs over TCP/IP and, while it is possible to code directly to TCP/IP, you might prefer to use a library that handles the details of the MQTT protocol for you. You will find there's a wide range of MQTT client libraries available at mqtt.org_, with the best place to start looking being the `Eclipse Paho project`_. IBM contributes to the development and support of many of these libraries."
msgstr ""
"MQTT는 TCP/IP 위에서 실행되며 TCP/IP에 직접 코딩할 수 있지만 사용자는 MQTT 프로토콜의 세부사항을 처리하는 라이브러리의 사용을 선호할 수 있습니다. 사용 가능한 광범위한 MQTT 클라이언트 라이브러리가 mqtt.org에 있으며 `Eclipse Paho 프로젝트`에서 검색을 시작하는 것이 가장 좋습니다. IBM은 이 라이브러리 중 다수의 개발 및 지원에 기여합니다. "

#: ..\docs\messaging\mqtt.rst:20
msgid "MQTT 3.1 is the version of the protocol that is in widest use today. Version 3.1.1 contains a number of minor enhancements, and has been ratified as an OASIS Standard."
msgstr ""
"MQTT 3.1은 오늘날 가장 광범위하게 사용되는 프로토콜의 버전입니다. 버전 3.1.1은 다수의 사소한 개선사항을 포함하고 있으며 OASIS 표준으로 승인되었습니다. "

#: ..\docs\messaging\mqtt.rst:23
msgid "One reason for using version 3.1.1 is that the maximum length of the MQTT Client Identifier (ClientId) is increased from the 23 character limit imposed by 3.1. The IoT service will often require longer ClientId's and will accept long ClientId's with either version of the protocol however some 3.1 client libraries check the ClientId and enforce the 23 character limit."
msgstr ""
"버전 3.1.1을 사용하는 한 가지 이유는 MQTT 클라이언트 ID(ClientId)의 최대 길이가 3.1의 제한인 23자보다 길어졌다는 점입니다. IoT 서비스는 더 긴 ClientId를 요구하는 경우가 종종 있으며 두 버전의 프로토콜에 대해 긴 ClientId를 승인하지만 일부 3.1 클라이언트 라이브러리는 ClientId를 확인하여 23자 제한을 적용합니다. "

#: ..\docs\messaging\mqtt.rst:35
msgid "MQTT client connection"
msgstr ""
"MQTT 클라이언트 연결"

#: ..\docs\messaging\mqtt.rst:36
msgid "Every registered organization has a unique endpoint which must be used when connecting MQTT clients for applications and devices in that organization."
msgstr ""
"등록된 모든 조직은 해당 조직의 애플리케이션 및 디바이스를 위해 MQTT 클라이언트를 연결할 때 사용해야 하는 고유 엔드포인트를 가지고 있습니다. "

#: ..\docs\messaging\mqtt.rst:39
msgid "**org\\_id**.messaging.internetofthings.ibmcloud.com"
msgstr ""
"**org\\_id**.messaging.internetofthings.ibmcloud.com"

#: ..\docs\messaging\mqtt.rst:45
msgid "Unencrypted client connection"
msgstr ""
"암호화되지 않은 클라이언트 연결"

#: ..\docs\messaging\mqtt.rst:47
msgid "Connect on port **1883**"
msgstr ""
"포트 **1883**에서 연결"

#: ..\docs\messaging\mqtt.rst:49
msgid "All information your device submits is being sent in plain text (including the authentication credentials for your device). We recommend the use of an encrypted connection whenever possible."
msgstr ""
"디바이스가 제출하는 모든 정보는 일반 텍스트로 전송됩니다(디바이스에 대한 인증 신임 정보 포함). 가능할 때마다 암호화된 연결을 사용하는 것이 좋습니다."

#: ..\docs\messaging\mqtt.rst:58
msgid "Encrypted client connection"
msgstr ""
"암호화된 클라이언트 연결"

#: ..\docs\messaging\mqtt.rst:60
msgid "Connect on port **8883** or **443** for websockets."
msgstr ""
"웹 소켓을 위해 포트 **8883** 또는 **443**에서 연결합니다. "

#: ..\docs\messaging\mqtt.rst:62
msgid "In many client libraries you will need to provide the server's public certificate in pem format.  The following file contains the entire certificate chain for \\*.messaging.internetofthings.ibmcloud.com: messaging.pem_"
msgstr ""
"다수의 클라이언트 라이브러리에서 사용자는 pem 형식으로 서버의 공용 인증서를 제공해야 합니다. 다음 파일에는 \\*.messaging.internetofthings.ibmcloud.com: messaging.pem에 대한 전체 인증서 체인이 포함되어 있습니다. "

#: ..\docs\messaging\mqtt.rst:68
msgid "Some SSL client libraries have been shown to not handle wildcarded domains, in which case, if you can not change libraries, you will need to turn off certificate checking."
msgstr ""
"일부 SSL 클라이언트 라이브러리는 와일드카드 도메인을 처리하지 않는 것으로 표시되었으며 이 경우 라이브러리를 변경할 수 없으면 인증서 확인을 꺼야 합니다. "

#: ..\docs\messaging\mqtt.rst:72
msgid "The IoT Foundation requires TLS v1.2. We suggest the following cipher suites: ECDHE-RSA-AES256-GCM-SHA384, AES256-GCM-SHA384, ECDHE-RSA-AES128-GCM-SHA256 or AES128-GCM-SHA256 *(as of Jun 1 2015)*."
msgstr ""
"IoT Foundation에서는 TLS v1.2를 요구합니다. ECDHE-RSA-AES256-GCM-SHA384, AES256-GCM-SHA384, ECDHE-RSA-AES128-GCM-SHA256 또는 AES128-GCM-SHA256 암호 스위트를 추천합니다. *(2015년 1월 1일 현재)*"

#: ..\docs\messaging\mqtt.rst:78
msgid "Device and application clients"
msgstr ""
"디바이스 및 애플리케이션 클라이언트"

#: ..\docs\messaging\mqtt.rst:79
msgid "We define two primary classes of thing: Devices & Applications"
msgstr ""
"디바이스와 애플리케이션이라는 사물의 두 가지 기본 클래스를 정의함"

#: ..\docs\messaging\mqtt.rst:81
msgid "The class of thing that your MQTT client identifies itself to the service as will determine the capabilities of your client once connected as well as the mechanism through which you will need to authenticate."
msgstr ""
"인증을 수행하는 데 사용해야 하는 메커니즘과 연결된 이후 클라이언트의 기능을 판별할 때처럼 MQTT 클라이언트가 서비스에 대해 자신을 식별하는 사물의 클래스입니다. "

#: ..\docs\messaging\mqtt.rst:85
msgid "Applications and devices also work with different MQTT topic spaces.  Devices work within a device-scoped topic space, whereas applications have full access to the topic space for an entire organization."
msgstr ""
"애플리케이션과 디바이스는 다양한 MQTT 주제 공간에 대해서도 작업합니다. 디바이스는 디바이스 범위 주제 공간 내에서 작업하지만 애플리케이션은 전체 조직에 대한 주제 공간에 대한 전체 액세스를 가집니다. "

#: ..\docs\messaging\mqtt.rst:89
msgid ":doc:`devices`"
msgstr ""
":문서:`디바이스`"

#: ..\docs\messaging\mqtt.rst:90
msgid ":doc:`applications`"
msgstr ""
":문서:`애플리케이션`"

#: ..\docs\messaging\mqtt.rst:99
msgid "Quality of service"
msgstr ""
"서비스 품질(QoS)"

#: ..\docs\messaging\mqtt.rst:100
msgid "The MQTT protocol provides three qualities of service for delivering messages between clients and servers: \"at most once\", \"at least once\" and \"exactly once\". Events and commands can be sent using any quality of service level, however you should carefully consider whether what the right level is for your needs.  It is not a simple case that QoS2 is \"better\" than QoS0."
msgstr ""
"MQTT 프로토콜은 클라이언트와 서버 간 메시지 전달을 위해 세 가지 서비스 품질(QoS)을 제공합니다(\"한 번 이하\", \"한 번 이상\", \"정확하게 한 번\"). 이벤트 및 명령은 모든 서비스 품질(QoS) 레벨을 사용하여 전송할 수 있지만 요구에 맞는 올바른 레벨이 무엇인지 주의해서 고려해야 합니다. QoS2가 QoS0보다 \"낫다\"는 단순한 케이스가 아닙니다. "

#: ..\docs\messaging\mqtt.rst:108
msgid "At most once (QoS0)"
msgstr ""
"한 번 이하(QoS0)"

#: ..\docs\messaging\mqtt.rst:109
msgid "The message is delivered at most once, or it might not be delivered at all. Delivery across the network is not acknowledged, and the message is not stored. The message could be lost if the client is disconnected, or if the server fails. QoS0 is the fastest mode of transfer. It is sometimes called \"fire and forget\"."
msgstr ""
"메시지가 한 번 이하로 전달되거나 전혀 전달되지 않습니다. 네트워크를 통한 전달은 수신확인 되지 않으므로 메시지가 저장되지 않습니다. 클라이언트의 연결이 끊기거나 서버가 실패하면 메시지가 유실될 수 있습니다. QoS0은 가장 빠른 전송 모드입니다. 이를 \"실행 후 무시(fire and forget)\"라고도 합니다. "

#: ..\docs\messaging\mqtt.rst:115
msgid "The MQTT protocol does not require servers to forward publications at QoS0 to a client. If the client is disconnected at the time the server receives the publication, the publication might be discarded, depending on the server implementation."
msgstr ""
"MQTT 프로토콜은 서버가 QoS0에서의 공개를 클라이언트에 전달하도록 요구하지 않습니다. 서버가 공개를 수신할 때 클라이언트의 연결이 끊기면 서버 구현에 따라 공개가 삭제될 수 있습니다. "

#: ..\docs\messaging\mqtt.rst:120
msgid "When sending real-time data on an interval we recommend using QoS0.  If a single message goes missing it does not really matter as another message will be sent shortly after containing newer data.  In this scenario the extra cost of using higher quality of service does not result in any tangible benefit."
msgstr ""
"일정한 간격으로 실시간 데이터를 전송하는 경우 QoS0를 사용하는 것이 좋습니다. 새 데이터를 포함한 직후 다른 메시지가 전송되므로 단일 메시지가 누락되어도 문제가 되지 않습니다. 이 시나리오에서는 높은 서비스 품질(QoS)을 사용하는 데 소요되는 추가 비용이 유형의 이점을 생성하지 않습니다. "

#: ..\docs\messaging\mqtt.rst:127
msgid "At least once (QoS1)"
msgstr ""
"한 번 이상(QoS1)"

#: ..\docs\messaging\mqtt.rst:128
msgid "The message is always delivered at least once. It might be delivered multiple times if there is a failure before an acknowledgment is received by the sender. The message must be stored locally at the sender, until the sender receives confirmation that the message has been published by the receiver. The message is stored in case the message must be sent again."
msgstr ""
"메시지는 항상 한 번 이상 전달됩니다. 송신자가 수신확인을 수신하기 전에 장애가 발생하는 경우 메시지가 여러 번 전달될 수 있습니다. 수신자가 메시지를 공개했다는 확인을 송신자가 수신할 때까지 메시지는 송신자 측에서 로컬로 저장되어야 합니다. 메시지를 다시 전송해야 하는 경우 메시지가 저장됩니다. "

#: ..\docs\messaging\mqtt.rst:136
msgid "Exactly once (QoS2)"
msgstr ""
"정확하게 한 번(QoS2)"

#: ..\docs\messaging\mqtt.rst:137
msgid "The message is always delivered exactly once. The message must be stored locally at the sender, until the sender receives confirmation that the message has been published by the receiver. The message is stored in case the message must be sent again. QoS2 is the safest, but slowest mode of transfer. A more sophisticated handshaking and acknowledgement sequence is used than for QoS1 to ensure no duplication of messages occurs."
msgstr ""
"메시지는 항상 정확하게 한 번 전달됩니다. 수신자가 메시지를 공개했다는 확인을 송신자가 수신할 때까지 메시지는 송신자 측에서 로컬로 저장되어야 합니다. 메시지를 다시 전송해야 하는 경우 메시지가 저장됩니다. QoS2는 가장 안전하지만 가장 느린 전송 모드입니다. 메시지 중복이 발생하지 않도록 하기 위해 QoS1보다 정교한 핸드쉐이크 및 수신확인 순서가 사용됩니다. "

#: ..\docs\messaging\mqtt.rst:144
msgid "When sending commands we recommend using QoS2.  In many cases, when processing commands you want to know that the command will only be actioned, and that it will be actioned only once.  This is one of the clearest examples of when the additional overhead of QoS2 has a clear benefit."
msgstr ""
"명령을 전송하는 경우 QoS2를 사용하는 것이 좋습니다. 많은 경우 명령을 처리할 때 명령이 한 번만 실행되는지 알고 싶어 합니다. 이는 QoS2의 추가적인 오버헤드에 명확한 이점이 있는 경우에 대한 명확한 예 중 하나입니다. "

#: ..\docs\messaging\mqtt.rst:151
msgid "Subscription Buffers and Clean Session"
msgstr ""
"구독 버퍼 및 정리 세션"

#: ..\docs\messaging\mqtt.rst:152
msgid "Each subscription from either a device or application is allocated a buffer of 5000 messages.  This allows for any application or device to fall behind the live data it is processing and build up a backlog of up to 5000 pending messages for each subscription it has made.  Once the buffer fills up, any new message will result in the oldest message in the buffer being discarded."
msgstr ""
"디바이스 또는 애플리케이션으로부터의 각각의 구독에는 5000개의 메시지라는 버퍼가 할당됩니다. 이를 통해 애플리케이션 또는 디바이스는 처리 중인 라이브 데이터보다 뒤쳐져서 작성한 각각의 구독에 대해 최대 5000개의 보류 중인 메시지의 백로그를 빌드할 수 있습니다. 버퍼가 가득 차고 난 후 새 메시지가 생성되면 버퍼의 가장 오래된 메시지가 삭제됩니다. "

#: ..\docs\messaging\mqtt.rst:158
msgid "The subscription buffer can be accessed using MQTT clean session option.  If clean session is set to true, a subscriber will start receiving messages from the buffer. If it is false the buffer is reset."
msgstr ""
"구독 버퍼는 MQTT 정리 세션 옵션을 사용하여 액세스할 수 있습니다. 정리 세션이 true로 설정되면 구독자는 버퍼로부터 메시지 수신을 시작합니다. false인 경우에는 버퍼가 재설정됩니다. "

#: ..\docs\messaging\mqtt.rst:162
msgid "This limit applies regardless of the quality of service setting used. Thus it is possible that a message sent at QoS1 or QoS2 may not be delivered to an application that is unable to keep up with the messages rate for the subscription(s) it has made."
msgstr ""
"이 제한은 사용된 서비스 품질(QoS) 설정에 관계없이 적용됩니다. 따라서 QoS1 또는 QoS2에서 전송된 메시지가 애플리케이션이 작성한 구독에 대한 메시지 비율을 맞출 수 없는 애플리케이션에 전달되지 못할 수 있습니다. "

